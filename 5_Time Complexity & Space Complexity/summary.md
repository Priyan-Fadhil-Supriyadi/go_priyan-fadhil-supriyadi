## (6) Time Complexity & Space Complexity

1. time complexity adalah bagaimana kita mengitung suatu algoritma atau suatu sistem yang berjalan dalam hal waktu. caranya yaitu pertama kita harus menentukan seberapa banyak operasi dominan yang dilakukan. operasi dominan merupakan operasi yang primitif seperti penambahan, perkalian, dsb. terdapat beberapa jenis time complexity. yang pertama adalah constant time - O(1) dimana operasi dominan hanya akan di eksekusi sebanyak 1 kali, yang kedua adalah linear time - O(n) dimana ketika melakukan input n maka operasi dominan akan di eksekusi sebanyak n kali, selanjutnya adalah logarithmic time - O(log n) dimana n akan dieksekusi sebanyak 2^x = n kali, kemudian ada quadratic time - O(n^2) yaitu ketika kita memiliki input n maka akan di eksekusi sebanyak n^2 kali. Selain itu ada juga exponential dan factorial time
2. sebuah komputer dapat melakukan pemrosesan data sebanyak 10^8 atau 100.000.000 operasi/1 detik. maka ketika kita sudah menentukan misalnya ternyata time complexity kita adalah O(n) lalu menginputkan 1 milyar data maka komputer akan memproses algoritma ini sebanyak 10 detik. namun berdasarkan beberapa penelitian usahakan kita tidak boleh memproses algoritma selama lebih dari 2 detik.
3. sebuah proses sebelum masuk kedalam cpu maka nilai yang dioperasikan akan disimpan didalam sebuah memory terlebih dahulu, memory ini adalah penyimpanan sementara. Space complexity berarti kita harus bisa menghitung berapa alokasi memori yang dibutuhkan dalam algoritma tersebut. cara menghitung space complexity adalah dengan menghitung seberapa banyak variable atau ruang yang dialokasikan ke memori. 

### Task
1. untuk membuat program bilangan prima dengan solusi yang lebih optimal yaitu dengan kompleksitas yang lebih cepat dari O(n) atau O(n/2) saya berfikir bahwa faktor bilangan bisa didapat kurang dari akar bilangan yang dicari faktornya. misal jika kita ingin tahu apakah 36 memiliki faktor bilangan selain 1 dan dirinya sendiri, maka kita hanya perlu mencari dari 2 sampai akar(36) yaitu 2-6, dimana 2,3, dan 6 merupakan faktor bilangan 36 sehingga dapat dipastikan bahwa 36 bukanlah bilangan prima sehingga saya mendapatkan time complexity hanya sebesar O(log n). Kemudian saya mengimplementasikan ide tersebut kedalam sebuah code, sehingga menjadi seperti ini.
<img src="screenshots/SS problem 1.PNG">

2. untuk membuat sebuah program yang dapat mengkalikan secara cepat bilangan eksponensial dengan time complexity yang lebih kecil dari O(n) maka saya membutuhkan bantuan library math dimana library tersebut dapat meng-operasikan bilangan berpangkat secara langsung sehingga kompleksitas yang saya dapatkan yaitu O(1). Kemudian saya implementasikan ide tersebut kedalam code menjadi seperti berikut.
<img src="screenshots/SS problem 2.PNG">